\graphicspath{{sections/02_GCP_HOLO_Optimization/}}

\chapter{GCP-HOLO: Generating High-Order Linkage Graphs for Path Synthesis}\label{sec:gcpholo}
One degree of freedom (1DOF) linkages are persistent in mechanical systems. However, designing linkages to follow a desired path, known as path synthesis, is challenging due to non-linearities, combinatorial nature, and strict geometric constraints. Current state-of-the-art algorithms cannot scale well to linkages with higher-order linkage graphs, which are required to satisfy more complicated paths for new mechanical systems, such as hopping and flying robots. One reason for this is that state-of-the-art algorithms spend the majority of the time exploring constraint-violating designs. This work uses an Assur group 0DOF linkage as a graph grammar rule to modify both linkage graph and spatial parameters, ensuring all designs are valid 1DOF linkages. Using this graph grammar, this paper formulates linkage path synthesis as a tree search and uses a Deep Reinforcement Learning (DRL) agent to search the space of kinematically feasible planar 1DOF linkages. This paper introduces a method using a Graph Convolution Policy for High-Order Linkage Graph Optimization called GCP-HOLO. An any-time algorithm, GCP-HOLO outputs linkages with 1-8 loops (4-16 bars) efficiently. When comparing the GCP-HOLO formulation to a recent state-of-the-art paper that solves a Mixed Integer Conic Program, GCP-HOLO generates sets of solutions of varying linkage complexities to 8 test trajectories in a quarter of the time. Extending GCP-HOLO with a global node optimization, such as Covariance Matrix Adaptation Evolutionary Strategy, the results quickly converge to finding better solutions for 4/8 tests, with the whole pipeline capable of a 13X speed increase. 

\section{Introduction}
In the long history of the path synthesis problem, there still lacks a scalable method for simultaneous graph and geometric parameter design for path synthesis of high-order linkage graphs. This paper defines a high-order linkage graph as having 3 or more loops or greater or equal to an 8-bar linkage. A solution for this problem can help engineers explore new applications for linkages in designing mechanical systems. Linkages consistently have resurgences in the design of mechanical systems due to their ability to transform circular motion into any arbitrary path and improve the mechanical advantage of the end effector, such as the force and torque advantages. Recently, with stronger computational tools \cite{plecnik_computational_2016}, the design of more complex linkages advanced areas in modern robot designs \cite{ramezani_bat_2016, FestoUSA2018BionicFlyingFox, plecnik_design_2017}.  The 8-bar linkage design reduced the number of actuators used on the robot enabling highly dynamic behavior with overall lower weight and cost \cite{ramezani_bat_2016}, \cite{plecnik_design_2017}. Current systems still primarily focus on pure geometric optimization, which requires expert knowledge from the end-user, such as which linkage graphs will lend themselves to the desired trajectory. This work seeks to reduce the expertise needed of the end-user in solving path synthesis by introducing a method called GCP-HOLO (Graph Convolution Policy for High-Order Linkage Graph Optimization) which: 
\begin{enumerate}
    \item Explores both linkage graph and linkage geometry simultaneously;
    \item Provides sets of solutions with varying linkage graphs topologies rather than a point solution; 
    \item Can be augmented with other design constraints specific to the desired task.
\end{enumerate}
The problem of linkage design is challenging due to the mixed discrete and continuous design variables, non-linearities, combinatorial nature, and strict geometric constraints. This paper focuses on linkages defined by rigid bars connected by revolute joints. The configuration of bars and joints defines the linkage graph, and the location of the revolute joints or bar lengths defines the linkage geometry. The linkage graph configuration problem is a combinatorial discrete number problem with a long history of research related to the generation of unique configurations \cite{mruthyunjaya_kinematic_2003}. A notable solution to this problem was by Tuttle, who found all possible 1DOF mechanisms with up to 1–6 loops (4–12 bars) to be 4.3×106 configurations \cite{tuttle_generation_1996}. The linkage geometry problem is a continuous problem and has an equally long history of investigation. A pivotal contribution in this area was from Freudenstein, who created an analytical approach to solving the path synthesis problem for a one-loop (four-bar) linkage \cite{FerdinandFreudenstein1955}. It may be surprising that the progress in solving the path synthesis problem for higher-order linkage graphs is still very much unsolved. Recent works like  \cite{plecnik_designing_2020} found the 1.5×106 solutions to a two-loop (six-bar) linkage graph for a path synthesis problem. This paper considers three-loop (eight-bar) or greater linkages as high-order linkage graphs because there are no analytical approaches to solving the path synthesis problem. A few works, such as \cite{lipson_evolutionary_2008, vermeer_kinematic_2018, pan_joint_2022}, have attempted to solve the path synthesis problem by combining the linkage graph and geometry. These methods greatly support the end-user, who may not be an expert in mechanism design. The linkage designs for all these problems must satisfy the 1DOF constraint and the strict physical constraints of the rigid bar connections defined by the revolute joints.

This paper provides an automated method to address the three goals defined prior. This paper presents a fixed homogeneous action space to iteratively grow a base linkage using the Assur group RRR 0DOF kinematic chain \cite{Assur1913InvestigationII.}. The problem is formulated as a tree search where a reinforcement learning (RL) agent is trained to learn a search heuristic to efficiently find designs that minimize the coupler trajectory to the goal. The search agent explores various depths of the graph to consider different linkage topologies to present as a solution set. The paper compares GCP-HOLO to a recent work that attempts to solve a similar problem using a mixed integer conic program (MICP) formulation. The paper shows an example of an application of a linkage system with secondary design constraints by applying the method to designing a linkage for a walking system based on the TrotBot footpath. Finally, a deeper evaluation of reinforcement learning variants’ performance is considered. This test compares the GCP-HOLO with on-policy updates, GCP-HOLO with off-policy, and a baseline random search. The main contributions of this work are as follows:
\begin{enumerate} 
    \item A tree search formulation of linkage path synthesis problem with RL search agent;
    \item Linkage latent state representation using graph convolution network (GCN);
    \item Fast linkage generation and simulation using 0DOF Assur group rule and symbolic kinematics;
    \item An OpenAI Gym environment for linkage design that can be used as a testbed for future RL algorithms.
\end{enumerate}

\section{Related Works}
\subsection{Fixed Linkage Graph Optimization}
Many approaches to the path synthesis problem fix the discrete linkage graph a priori and optimize only the continuous geometric parameters to minimize the distance to the desired coupler trajectory. A state-of-the-art method for path synthesis with high precision uses a dimensional synthesis method known as homotopy continuation \cite{plecnik_computational_2016}. That method converts the non-linear system of equations that define the linkage in the various key point positions into a high-order polynomial. The formulation is then converted into a root-finding problem whichis solved for the geometric parameters. That methodcan solve a path that consists of nine sample points for a four-bar linkage \cite{wampler_complete_1992} and up to 11sample points for a six-bar linkage \cite{plecnik_design_2016}. The maximum number of sample points is determined by the number of unknown parameters defining the mechanism, for example, link lengths or joint positions. A key limitation of that method is the computational complexity and restriction on the number of precision points. Because of these scaling issues, no further extensions for higher-order linkages exist. That work solved the exact solutions that satisfy the precision points for low-order linkage graphs (four-bar and six-bar), where the problem this paper addresses is path synthesis for high-order linkage graphs ($\geq$ eight-bar). 

Stochastic optimization techniques, such as the covariance matrix adaptation evolutionary strategy (CMA-ES), are an approach that is capable of optimizing geometric parameters of higher-order linkages \cite{thomaszewski_computational_2014}. That method converges to reasonable solutions when the design parameters are bounded and strong initial solutions are provided. That method can be computationally expensive as most designs the method considers are kinematically invalid due to the strict geometric constraints. CMA-ES also fails when the optimization is unbounded, as many solutions tend towards infinity or propose unrealistic design parameters. GCP-HOLO can be extended using CMA-ES to improve the solutions through small changes to the joint locations. Section 4.1 shows an example of GCP-HOLO’s solutions improved with CMA-ES. 

The linkage kinematics can be described as closed-form equations for a class of linkages proposed by  \cite{bacher_linkedit_2015}, known as simple kinematic loops. Bächer et al. introduced a gradient-based method to update the continuous parameters in a real-time interactive system \cite{bacher_linkedit_2015}. That work showed that gradient descent is well suited when exploring the spatial parameters of a single linkage graph where a designer can influence different aspects of the linkage, such as scaling, specific node trajectories, or path constraints. That gradient-based approach quickly settles in a local minimum and only provides point-based solutions. That method could also be used to improve the final designs of GCP-HOLO, but since it natively does not consider the linkage graph variants, that work is not considered further in this paper. These fixed linkage graph approaches to path synthesis designs cannot simply be extended by iterating over all linkage graphs as the number of variations grows exponentially, with over 4.5×106 linkage graphs for linkages with less than 6 loops or 14 bars \cite{tuttle_generation_1996}.

\subsection{Simultaneous Linkage Design Optimization}
Recent work by Pan et al. \cite{pan_joint_2022} represents the problem as a MICP and solves for the optimal solution using a branch and bound method. That work showed significant progress in solving the planar path synthesis where both linkage graph and geometric parameters are solved simultaneously. However, some shortcomings are that the method cannot guarantee that intermediate designs are feasible, which requires the method to converge before a solution can be considered. Another limitation is that the computational complexity grows exponentially as the approach considers designs with higher linkage graphs, more sample points, or finer discretization. Finally, the method only provides a point solution, which may not be preferred in design automation as there are many considerations in the design that might not be expressed in the objective function, such as manufacturability and assembly. In this work, GCP-HOLO is an anytime algorithm that generates only kinematically feasible linkages addressing the intermediate design feasibility. GCP-HOLO also suffers from computational complexity but to a much lesser extent since invalid designs are prohibited from the formulation of the grammar rule. Finally, GCP-HOLO outputs a set of linkage designs of varying linkage topologies rather than a point solution. While MICP has some optimality guarantees, the planar path synthesis problem contains many local minima with objectives close to the optimal solution, as shown in the results in this paper. Therefore, this work can find several strong solutions in significantly less time, lending itself advantageously in certain situations. That work is compared to the current method in Sec. 4.1 as it most similarly addresses a comparable problem. 

Zhao et al. \cite{zhao_planar_2016} provided a mixed exact and approximate motion realization method that finds the optimal planar dyad chain. The planar dyad chain can then be converted into four-bar linkage solutions. Their approach converts the desired trajectory through kinematic mapping to a higher dimensional representation, the Image Space, that enables them to solve a least square fitting problem. The solution parameters from the least squares fitting are correlated to the different planar dyad types (RR, PR, RP). The advantage of this approach is that the solution found can have up to four precision poses and an arbitrary number of inexact poses. One limitation of this approach is that the desired trajectory must be satisfied by a planar dyad, which could be hard to determine a priori if the dyad is well suited for the path. 

Lipson proposed a genetic algorithm for linkage synthesis that simultaneously acts on the design’s linkage graph and spatial parameters with graph grammars \cite{lipson_evolutionary_2008}. Graph grammars are a set of pre-specified rules that modifies the current state by either adding to the graph, removing parts of the graph, or augmenting the graph structure. The graph grammars that Lipson defined were applied to the rigid bars of the linkage, which requires the forward kinematics (FK) of the new design to be fully re-evaluated. Since the FK must be evaluated thousands of times in genetic algorithms and RL, an efficient method for computing the FK must be considered. This paper defines the grammar rule on the nodes to address this issue, which only requires the added component’sFK to be evaluated using the symbolic kinematics method. Another limitation of Lipson’s grammar rules is the lack of constraints on the new joint’s initial location, which can lead to the evaluation of manykinematically degenerate designs. This paper uses a simplif ied constraint satisfaction criteria to evaluate the validity of new joint locations quickly. Finally, this paper extends the applications shown in Lipson, which only explored linkage design for a straight-line synthesis problem. This paper is applied to the more general path synthesis problem.

Vermeer et al. \cite{vermeer_kinematic_2018} trained a deep RL agent to learn a policy to apply Lipson’s grammar rules. To use Lipson’s grammar in their RL framework, Vermeer et al. introduced a spatial constraint such that the new node added forms an isosceles triangle. This constraint converts the graph grammar to a fixed action space more suitable for RL. However, that constraint impaired their method’s performance in generating designs and failed to achieve comparable results to Lipson’s method. That constraint also fails to guarantee a valid design since the isosceles triangle only satisfies the linkage constraints in the first time-step and not the whole trajectory. To address these limitations, this work replaces their spatial constraint with a set of scaffold nodes—a set of potential initial joint locations. This achieves a suitable action space for the RL agent with relaxed design limitations. This paper also uses a simplified constraint satisfaction criteria that check the validity of the node positions through the whole trajectory and not the initial time-step to prevent the evaluation of constraint-violating designs. Vermeer et al. defined the state of the linkage using hand-crafted features. This is inferior to learned feature representation using deep learning \cite{nanni_handcrafted_2017}. Therefore, in this work, a graph embedding network is used to learn the latent features of the current design state.

GCP-HOLO improves and differs from the prior works by defining a graph grammar rule that does not affect prior revolute joints’ trajectories and therefore avoids re-evaluation of the full forward kinematics. GCP-HOLO introduces scaffold nodes to extend the linkage configuration with a simplified constraint satisfaction criteria that quickly identifies the set of valid states, ensuring an anytime algorithm that generates valid 1DOF linkages. GCP-HOLO converts the graph representation of the linkage into a vector through a learned mapping. Finally, GCP-HOLO trains an RL agent to learn a search direction that improves the generation of linkages to satisfy the path synthesis problem.

\subsection{Reinforcement Learning in Design}
GCP-HOLO was inspired by several recent works that used deep RL agents to find solutions for design automation problems. Similar methods to GCP-HOLO have been used in solving problems related to truss design \cite{raina_learning_2019}, molecules design \cite{you_graph_2018}, and robot design \cite{whitman_modular_2020, zhao_robogrammar_2020}. RL-based methods provide a sequential design approach that Raina et al. [19] stated is comparable to human engineering design. You et al. argued that deep RL methods are more robust than other machine learning-based generative methods for designing physical systems, as RL can ensure that all physical constraints of the design problem are satisfied \cite{you_graph_2018}. GCP-HOLO uses reinforcement learning rather than other tree search methods, as it has been shown in \cite{you_graph_2018, whitman_modular_2020, zhao_robogrammar_2020, raina_goal-directed_2021} to outperform search algorithms, such as Monte Carlo Tree Search and best-first search.

Several areas differentiate the RL pipelines in each of those works. First, the state representation of the design can vary. Trusses, molecules, and robot configurations are all fixed systems, whereas linkages are time-varying periodic systems. For example, in Raina et al. \cite{raina_learning_2019}, images of trusses are used to evaluate the current state of the design. In  \cite{you_graph_2018, whitman_modular_2020, zhao_robogrammar_2020}, the design state of the molecule and robots are represented as a graph. This work uses a graph representation to represent the time-varying linkage. Second is the agent design itself; Whitman et al. \cite{whitman_modular_2020}, and Zhao et al. \cite{zhao_robogrammar_2020}, proposed deep Q-network (DQN), an off-policy network, and You et al. \cite{you_graph_2018}, used proximal policy optimization (PPO), an on-policy algorithm. An on-policy RL algorithm updates the policy network directly responsible for selecting the action with the most recent data generated from the rollouts. An off-policy RL algorithm keeps track of a history of data generated from the rollouts and randomly samples from this buffer to update the network. This work explicitly compares the different policies’ performance for the linkage generation problem.

\section{Method}
Section 3.1 describes the class of linkages that this work considers and the simulation method to obtain the coupler trajectory. Section 3.2 describes the GCP-HOLO algorithm, which includes Sec. 3.2.1, describing the linkage state representation as a graph and the GCN to learn the latent state representation. Section 3.2.2 defines the action space from the graph grammar rule to explore linkage designs. Section 3.2.3 shows the objective of the path synthesis problem and reward design used to train the reinforcement learning agent. Finally, Sec. 3.2.4 describes the different types of reinforcement learning algorithms that can be used and the training process for the method.

\subsection{Linkage Formulation}
The kinematic chains this work designs can be understood as 1DOF high-order planar linkage graphs with simple kinematic loops. This section provides a breakdown of each of those terms to better inform the reader. One degrees-of-freedom (1DOF) defines the number of input variables needed to define the linkage pose fully. The type of linkages this paper designs consists of a set of moveable and fixed revolute joints connected by a set of rigid links and a motor input. For the 1DOF system knowing the angle of the motor input is sufficient to know the position of the rest of the mechanism. A complete revolution of the motor generates periodic paths for each moveable revolute joint. Gruebler’s formula, shown in Eq. (1), can be used to verify the degrees-of-freedom of the system:
\begin{equation}
    DOF = 3(n-1)-2j
\end{equation}
where n is the total number of links, j is the total number of revolute joints.

In planar mechanisms, all the revolute joints and rigid bars exist in the XY-plane. This is useful for designing linkages in simulation and determining the trajectories of the revolute joints. This can cause conflicts when converting designs from simulation to reality as the manufacturability and linkage assembly aren’t considered.

The configuration of the revolute joints and rigid bar components describes the linkage graph. The rigid bars in the linkage create closed loop structures. The linkage community, rather than describing the systems by the loops refers to them as four-bar (one loop), six-bar (two loops), eight-bar (three loops), etc. This paper defines higher-order linkage graphs with linkages that have $\geq$3 active loops, this is because there are no analytical approaches to solving the path synthesis of linkages with $\geq$3 active loops. The Jansen linkage in Fig. 1 is an example of a high-order linkage graph as it contains three loops [24]. This work uses the minimum cycle basis method to find the number of active loops that comprises the linkage graph [25].

In our work, the forward kinematics must be evaluated hundreds of thousands if not millions of times. A recursive approach for solving the forward kinematics for closed loop systems provides faster evaluations than constraint-based methods as described in Ref. [26]. Bächer et al. [16] described a recursive method, symbolic kinematics, to quickly evaluate the forward kinematics for a subset of linkage graphs made up of revolute joints. This method does not work for all linkage graphs but does span 7 out of the 11 planar 1DOFeight-bar linkage topologies described by Tsai and Mccarthy [27]. Symbolic kinematics is also not currently suited for systems with prismatic joints, so prismatic joints are not considered in this work. Symbolic kinematics represents the linkage by its joint positions and distance constraints between connected revolute joints. The crank joint location is determined from the motor input angles, given by:
\begin{equation}
    x_{crank}(t)=R(\lambda\theta(t))*(x_{crank}(1)-x_{motor})+x_{motor} \forall t\in[2,T]
\end{equation}
where $R(\cdot)$ is the 2x2 rotation matrix, $\lambda$ is the direction of the motor with $\lambda = \begin{cases}
    1, & \text{CCW}.\\
    -1, & \text{CW}.
  \end{cases}$ and $x(t)$ is the planar position of the joint at time $t$.


%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "../thesis"
%%% End: